TODO, should be ez paste
https://www.unknowncheats.me/forum/counterstrike-source/94725-perfect-silent-aim.html

cat_nohomo 
Im gonna make that, its gonna make ur screen rainbow with text that says ur gay

Sticky explosion radius esp

Projectile lines

add horizontal health bars

make auto-sticky vis check use a center hitbox

AA stuff
3600 - 89
-7845 - subb

Remake edge by getting left and right dist untill wall, then tracing left and right.
If hit, trace opposing side. if opposing hits too, continue untill u run out of left n right dist. 
If you run out of left and right distance, use side with the least distance to edge on.








// Get hitbox seperate from cache
Vector EntityOriginOffset(CachedEntity* entity, int hitbox) {
	// Check to prevent crashes
	if (CE_BAD(entity)) return Vector();
	logging::Info("Getting bone offset");
	// Create a storage var for model
	model_t *model;
	model = 0;
	// Try to get a model
	SAFE_CALL(model = (model_t*)RAW_ENT(entity)->GetModel());
	if (!model) return Vector();
	
	// Use the model to get a studip model
	studiohdr_t *shdr = g_IModelInfo->GetStudiomodel(model);
	if (!shdr) return Vector();
	
	// Use the studio model to get a hitbox set
	mstudiohitboxset_t *hitbox_set = shdr->pHitboxSet(CE_INT(entity, netvar.iHitboxSet));
	
	if (!dynamic_cast<mstudiohitboxset_t*>(hitbox_set)) return Vector();
	
	// Use the hitbos set to get studio bbox
	hitbox_cache::CachedHitbox cached_hb;
	mstudiobbox_t* bbox = hitbox_set->pHitbox(hitbox);
	
	//Create a storage vector for bones and setup them
	matrix3x4_t bones[128];
	RAW_ENT(entity)->SetupBones(bones, 128, 0x100, CE_FLOAT(entity, netvar.m_flSimulationTime));
	
	//Get min and max of hitbox
	VectorTransform(bbox->bbmin, bones[bbox->bone], cached_hb.min);
	VectorTransform(bbox->bbmax, bones[bbox->bone], cached_hb.max);
	
	// Return the center of the hitbox
	return (cached_hb.min + cached_hb.max) / 2;
}











Old todo stuff
/////////////////////////////////////////////////////////////////////////////////
//TODO PLANNED

add check for wait for charge user setting to ambasador check
Make a switch to make sentry low priority
Make ubercharge esp color RGB when fully charged
Add ignore gunslinger to melee crit
add teleporter count down esp and arrow
add spy cloak esp

//
/////////////////////////////////////////////////////////////////////////////////


/////////////////////////////////////////////////////////////////////////////////
//TODO Idea or plan to make work but not implimented

//TODO Fix wrangler aimbot
	///// 
	// Add this netvar
	m_hBuilder = gNetvars.get_offset("DT_BaseObject", "m_hBuilder");

	///// 
	// Add this func to helpers

	// Function to attemt to find a sentry owned by the entity input into the parameter
	CachedEntity* FindOwnerEntSentry(CachedEntity* owner) {
		// Create a book-keeping var
		CachedEntity* ent;
		// For loop to loop through entitys
		for (int i = 0; i <= HIGHEST_ENTITY; i++) {
			// Save for loop tick as entity
			ent = ENTITY(i);
			// Test the ent if dormant
			if (CE_BAD(ent)) continue;
			// Check ent if building
			if (ent->m_Type != ENTITY_BUILDING) continue;
			// Check if ent is sentry gun
			if (ent->m_iClassID != CL_CLASS(CObjectSentrygun)) continue;
			// Grab the netvar for the builder of the ent
			int buldingOwner = CE_INT(ent, netvar.m_hBuilder) & 0xFFF;
			// If the buildings builder ent is the one input of the parameter, then return it
			if (ENTITY(buldingOwner) == owner) {
				// Return the ent which should be a sentry owned by the ent input into the func
				return ENTITY(ent);
			}
		}
		// If no building is found, just return with -1
		return -1;
	}

	///// 
	// Use that func to vis check from owners sent for the target

		// If the player is using a wrangler, then we vis check from the owners sentry
		if (g_pLocalPlayer->weapon()->m_iClassID == CL_CLASS(CTFLaserPointer)) {
			CachedEntity* owned_building = FindOwnerEntSentry(LOCAL_E);
			// If the owners building is a good ent, then we vis check from the target to the building
			if (CE_GOOD(owned_building)) {
				// Vis check starting from the target player ending at the building
				if (!VisCheckEntFromEntVector(GetBuildingPosition(owned_building), entity, owned_building)) return false; 
			// If the building is bad, then we just dont aim with the wrangler
			} else {
				return false;
			}
		}

//
/////////////////////////////////////////////////////////////////////////////////

//Fix achievements getting blocked
   *MakePtr(bool, g_pAchievementMgr, 0x1E7) = 0;
		
		
/////////////////////////////////////////////////////////////////////////////////
//TODO Night mode for tf2
		
sky_halloween_night_01 

void PerformNightmode()
{
	static bool bPerformed = false, bLastSetting;
	
	C_BasePlayer* pLocal = CSGO::EntList->GetClientEntity(CSGO::Engine->GetLocalPlayer());
	
	static ConVar* sv_skyname = CSGO::CVar->FindVar("sv_skyname");
	sv_skyname->nFlags &= ~FCVAR_CHEAT; // something something dont force convars
	
	if(!pLocal || !TF2::Engine->IsConnected() || !CSGO::Engine->IsInGame())
		return;
	
	if(!bPerformed)
	{
		for(auto i = CSGO::MaterialSystem->FirstMaterial(); i != CSGO::MaterialSystem->InvalidMaterial(); i = CSGO::MaterialSystem->NextMaterial(i))
		{
			static IMaterial* pMaterial = CSGO::MaterialSystem->GetMaterial(i);
			
			if(!pMaterial || pMaterial->IsErrorMaterial())
				continue;
				
			if(strstr((pMaterial->GetTextureGroupName(), "World") || strstr(pMaterial->GetTextureGroupName(), "StaticProp"))
			{
				if(bLastSetting)
				{
					sv_skyname->SetValue("sky_nightfall_01"); 
					pMaterial->SetMaterialVarFlag(MATERIAL_VAR_TRANSLUCENT, false); // walls were translucent for me for some odd reason, probably p100 codenz :/
					pMaterial->ColorModulate(0.15, 0.15, 0.15); 
				}
				else
				{
					sv_skyname->SetValue("vertigoblue_hdr"); // fixme: i was too lazy to backup old value
					pMaterial->ColorModulate(1.00, 1.00, 1.00);
				}
			}
		}
	}
	
	if(bLastSetting != Settings::bVisualNightmode)
	if(bLastSetting != Settings::bVisualNightmode)
	{
		bLastSetting = Settings::bVisualNightmode;
		
	}
}
			   
	void CMiscHacks::SkyShit()
    {
        static bool bPerformed = false, bLastSetting;

        bool pLocal = Interfaces::EntList->GetClientEntity(Interfaces::Engine->GetLocalPlayer());

        static ConVar* sv_skyname = Interfaces::CVar->FindVar("sv_skyname");
        sv_skyname->nFlags &= ~FCVAR_CHEAT; // something something dont force convars

        if (!pLocal || !Interfaces::Engine->IsConnected() || !Interfaces::Engine->IsInGame())
            return;

            for (auto i = Interfaces::MaterialSystem->FirstMaterial(); i != Interfaces::MaterialSystem->InvalidMaterial(); i = Interfaces::MaterialSystem->NextMaterial(i))
            {
                static IMaterial* pMaterial = Interfaces::MaterialSystem->GetMaterial(i);

                if (!pMaterial || pMaterial->IsErrorMaterial())
                    continue;

                if (strstr(pMaterial->GetName(), "World") || strstr(pMaterial->GetName(), "StaticProp"))
                {
                    sv_skyname->SetValue("sky_csgo_night02");
                    pMaterial->SetMaterialVarFlag(MATERIAL_VAR_TRANSLUCENT, false); // walls were translucent for me for some odd reason, probably p100 codenz :/
                    pMaterial->ColorModulate(0.15, 0.15, 0.15);
                }
            }
    }
	
	
	
	CTFShotgunBuildingRescue

https://hastebin.com/qumupujimo.cpp
https://www.unknowncheats.me/forum/counterstrike-global-offensive/215804-night-mode.html
csgo's material system uses shit like `CSGO::MaterialSystem->FirstMaterial()`
Does tf2 use `TF2::MaterialSystem->` or something else

//
/////////////////////////////////////////////////////////////////////////////////







/////////////////////////////////////////////////////////////////////////////////
//TODO Multi-point

u got AABB hitbox
shrink hitbox to 90%
2 points in 3D space
x1 y1 z1  x2 y2 z2
now mix em up and you got like 8 possible outcome vectors
9th is the center one


//
/////////////////////////////////////////////////////////////////////////////////

use with aimbot to fix taunting hitbox issue
RemoveCondition<TFCond_Taunting>(entity)

end of old todo stuff














Stuff from sdk for hitbox rotation
void stuff() {
	if () {
		// Create vars for the loop to use
		hitbox_cache::CachedHitbox* hb;
		Vector hb_min, hb_max;
		
		Vector position;
		QAngle angles;
		
		// Loop through hitboxes drawing stuff
		for (int i = 0; i <= 17; i++) {
			hb = entity->hitboxes.GetHitbox(i);
			if (!draw::WorldToScreen(hb->min, hb_min) || !draw::WorldToScreen(hb->max, hb_max)) continue;
			
			mstudiobbox_t *pbox = hb->box;
			
			
		}
	}
}
		

void CBaseAnimating::DrawServerHitboxes( float duration /*= 0.0f*/, bool monocolor /*= false*/  )
{
	for ( int i = 0; i < set->numhitboxes; i++ )
	{
		mstudiobbox_t *pbox = set->pHitbox( i );

		GetBonePosition( pbox->bone, position, angles );

		NDebugOverlay::BoxAngles( position, pbox->bbmin * GetModelScale(), pbox->bbmax * GetModelScale(), angles, r, g, b, 0 ,duration );
	}
}
void CBaseAnimating::GetBonePosition ( int iBone, Vector &origin, QAngle &angles )
{
	CStudioHdr *pStudioHdr = GetModelPtr( );

	matrix3x4_t bonetoworld;
	GetBoneTransform( iBone, bonetoworld );
	
	MatrixAngles( bonetoworld, angles, origin );
}

void MatrixAngles( const matrix3x4_t& matrix, float *angles ) { 

	float forward[3];
	float left[3];
	float up[3];

	forward[0] = matrix[0][0];
	forward[1] = matrix[1][0];
	forward[2] = matrix[2][0];
	left[0] = matrix[0][1];
	left[1] = matrix[1][1];
	left[2] = matrix[2][1];
	up[2] = matrix[2][2];

	float xyDist = sqrtf( forward[0] * forward[0] + forward[1] * forward[1] );
	
	// enough here to get angles?
	if ( xyDist > 0.001f ) {
		// (yaw)	y = ATAN( forward.y, forward.x );		-- in our space, forward is the X axis
		angles[1] = RAD2DEG( atan2f( forward[1], forward[0] ) );

		// (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
		angles[0] = RAD2DEG( atan2f( -forward[2], xyDist ) );
		
		// (roll)	z = ATAN( left.z, up.z );
		angles[2] = RAD2DEG( atan2f( left[2], up[2] ) );
		
	} else {	// forward is mostly Z, gimbal lock-
		
		// (yaw)	y = ATAN( -left.x, left.y );			-- forward is mostly z, so use right for yaw
		angles[1] = RAD2DEG( atan2f( -left[0], left[1] ) );

		// (pitch)	x = ATAN( -forward.z, sqrt(forward.x*forward.x+forward.y*forward.y) );
		angles[0] = RAD2DEG( atan2f( -forward[2], xyDist ) );

		// Assume no roll in this case as one degree of freedom has been lost (i.e. yaw == roll)
		angles[2] = 0;
	}
}

void RenderWireframeBox( const Vector &vOrigin, const QAngle& angles, const Vector &vMins, const Vector &vMaxs, Color c, bool bZBuffer )
{
	Vector p[8];
	GenerateBoxVertices( vOrigin, angles, vMins, vMaxs, p );
	// DO DRAW STUFF HERE FROM VECTOR TO VECTOR
}
	
	
static void GenerateBoxVertices( const Vector &vOrigin, const QAngle& angles, const Vector &vMins, const Vector &vMaxs, Vector pVerts[8] ) {
	
	// Build a rotation matrix from orientation
	matrix3x4_t fRotateMatrix;
	AngleMatrix( angles, fRotateMatrix );

	Vector vecPos;
	for ( int i = 0; i < 8; ++i )
	{
		vecPos[0] = ( i & 0x1 ) ? vMaxs[0] : vMins[0];
		vecPos[1] = ( i & 0x2 ) ? vMaxs[1] : vMins[1];
		vecPos[2] = ( i & 0x4 ) ? vMaxs[2] : vMins[2];

		VectorRotate( vecPos, fRotateMatrix, pVerts[i] );
		pVerts[i] += vOrigin;
	}
}

// Use Angles to create a matrix
void AngleMatrix( const QAngle &angles, matrix3x4_t& matrix ) {
	float sr, sp, sy, cr, cp, cy;
	
	SinCos( DEG2RAD( angles[YAW] ), &sy, &cy );
	SinCos( DEG2RAD( angles[PITCH] ), &sp, &cp );
	SinCos( DEG2RAD( angles[ROLL] ), &sr, &cr );
	
	matrix[0][0] = cp*cy;
	matrix[1][0] = cp*sy;
	matrix[2][0] = -sp;

	float crcy = cr*cy;
	float crsy = cr*sy;
	float srcy = sr*cy;
	float srsy = sr*sy;
	matrix[0][1] = sp*srcy-crsy;
	matrix[1][1] = sp*srsy+crcy;
	matrix[2][1] = sr*cp;

	matrix[0][2] = (sp*crcy+srsy);
	matrix[1][2] = (sp*crsy-srcy);
	matrix[2][2] = cr*cp;

	matrix[0][3] = 0.0f;
	matrix[1][3] = 0.0f;
	matrix[2][3] = 0.0f;
}


void VectorRotate( const float *in1, const matrix3x4_t& in2, float *out )
{
	out[0] = DotProduct( in1, in2[0] );
	out[1] = DotProduct( in1, in2[1] );
	out[2] = DotProduct( in1, in2[2] );
}










Compeditive crash

Thread 1 "hl2_linux" received signal SIGABRT, Aborted.
0xf771ec89 in __kernel_vsyscall ()
#0  0xf771ec89 in __kernel_vsyscall ()
#1  0xf74e3ea9 in raise () from /lib/i386-linux-gnu/libc.so.6
#2  0xf74e5407 in abort () from /lib/i386-linux-gnu/libc.so.6
#3  0xf72d474f in __gnu_cxx::__verbose_terminate_handler() () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#4  0xf72d20d4 in ?? () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#5  0xf72d214d in std::terminate() () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#6  0xf72d2400 in __cxa_throw () from /usr/lib/i386-linux-gnu/libstdc++.so.6
#7  0xd3866a19 in entity_cache::Get (idx=<optimized out>) at src/hacks/../entitycache.h:145
#8  hacks::shared::esp::ProcessEntity (ent=0xd3b75758 <entity_cache::array+3000>) at src/hacks/ESP.cpp:452
#9  0xd3866e07 in hacks::shared::esp::CreateMove () at src/hacks/ESP.cpp:76
#10 0xd3852ccb in CreateMove_hook (thisptr=<optimized out>, inputSample=<optimized out>, cmd=<optimized out>) at src/hooks/CreateMove.cpp:192
#11 0xdc4b3685 in ?? () from /home/iris/.local/share/Steam/steamapps/common/Team Fortress 2/tf/bin/client.so















